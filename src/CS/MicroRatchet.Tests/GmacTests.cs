using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Xunit;

namespace MicroRatchet.Tests
{
    public class GmacTests
    {
        [InlineData(4, 32, 320, 128)]
        [InlineData(32, 32, 32, 128)]
        [InlineData(16, 32, 32, 128)]
        [InlineData(4, 32, 32, 128)]
        [InlineData(32, 32, 64, 128)]
        [InlineData(16, 32, 64, 128)]
        [InlineData(4, 32, 64, 128)]
        [InlineData(32, 32, 32, 96)]
        [InlineData(16, 32, 32, 96)]
        [InlineData(4, 32, 32, 96)]
        [InlineData(32, 32, 64, 96)]
        [InlineData(16, 32, 64, 96)]
        [InlineData(4, 32, 64, 96)]
        [Theory]
        public void BasicGmacTests(int nonceBytes, int keyBytes, int dataBytes, int macSize)
        {
            RandomNumberGenerator rng = new RandomNumberGenerator();
            byte[] nonce = rng.Generate(nonceBytes);
            byte[] key = rng.Generate(keyBytes);
            byte[] data = rng.Generate(dataBytes);

            GMac gmac = new GMac();
            gmac.Init(key, nonce, macSize);
            gmac.Process(new ArraySegment<byte>(data));
            byte[] mac = gmac.Compute();

            var bcgmac = new Org.BouncyCastle.Crypto.Macs.GMac(new GcmBlockCipher(new AesEngine()), macSize);
            bcgmac.Init(new ParametersWithIV(new KeyParameter(key), nonce));
            bcgmac.BlockUpdate(data, 0, data.Length);
            byte[] bcmac = new byte[bcgmac.GetMacSize()];
            bcgmac.DoFinal(bcmac, 0);
            
            Assert.Equal(bcmac, mac);
        }

        [Fact]
        public void ReuseKeyTest()
        {
            RandomNumberGenerator rng = new RandomNumberGenerator();
            byte[] nonce1 = rng.Generate(16);
            byte[] nonce2 = rng.Generate(16);
            byte[] key = rng.Generate(32);
            byte[] data1 = rng.Generate(64);
            byte[] data2 = rng.Generate(64);

            GMac gmac = new GMac();
            gmac.Init(key, nonce1, 96);
            gmac.Process(new ArraySegment<byte>(data1));
            byte[] mac1 = gmac.Compute();
            gmac.Init(key, nonce2, 96);
            gmac.Process(new ArraySegment<byte>(data2));
            byte[] mac2 = gmac.Compute();

            var bcgmac = new Org.BouncyCastle.Crypto.Macs.GMac(new GcmBlockCipher(new AesEngine()), 96);
            bcgmac.Init(new ParametersWithIV(new KeyParameter(key), nonce1));
            bcgmac.BlockUpdate(data1, 0, data1.Length);
            byte[] bcmac1 = new byte[bcgmac.GetMacSize()];
            bcgmac.DoFinal(bcmac1, 0);
            bcgmac.Init(new ParametersWithIV(new KeyParameter(key), nonce2));
            bcgmac.BlockUpdate(data2, 0, data2.Length);
            byte[] bcmac2 = new byte[bcgmac.GetMacSize()];
            bcgmac.DoFinal(bcmac2, 0);


            Assert.Equal(bcmac1, mac1);
            Assert.Equal(bcmac2, mac2);
        }

        [InlineData(new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }, new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, new byte[] { 0x88, 0x0b, 0x0d, 0x2b, 0x48, 0xf1, 0x66, 0xd7, 0x4b, 0x78, 0x05, 0x5e, 0xfe, 0x91, 0x6c, 0x31 })]
        [InlineData(new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }, new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }, new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }, new byte[] { 0x2e, 0x32, 0xae, 0x56, 0x84, 0xec, 0x3b, 0x3b, 0x9e, 0x65, 0xd5, 0xf3, 0x42, 0xe1, 0x56, 0x1b })]
        [InlineData(new byte[] { 0x65, 0xc1, 0x92, 0xe8, 0xe1, 0xce, 0xce, 0x62, 0x79, 0x0b, 0x98, 0x17, 0x1a, 0x2f, 0xef, 0xff }, new byte[] { 0x2f, 0x1f, 0x8c, 0x51, 0xe5, 0x7e, 0x95, 0x98, 0xf7, 0x7d, 0x08, 0xd8, 0x5f, 0x94, 0xec, 0x92 }, new byte[] { 0xdc, 0xa0, 0x3c, 0xd7, 0x4b, 0x59, 0x29, 0xe6, 0xe3, 0x49, 0x2c, 0xa9, 0x91, 0x59, 0xcc, 0x84 }, new byte[] { 0x05, 0x3e, 0xb4, 0x79, 0x79, 0xa2, 0x87, 0x34, 0x92, 0x02, 0xa1, 0x8d, 0x2f, 0x53, 0x9f, 0x31 })]
        [InlineData(new byte[] { 0x65, 0xc1, 0x92, 0xe8, 0xe1, 0xce, 0xce, 0x62, 0x79, 0x0b, 0x98, 0x17, 0x1a, 0x2f, 0xef, 0xff }, new byte[] { 0x2f, 0x1f, 0x8c, 0x51, 0xe5, 0x7e, 0x95, 0x98, 0xf7, 0x7d, 0x08, 0xd8, 0x5f, 0x94, 0xec, 0x92 }, new byte[] { 0xdc, 0xa0, 0x3c, 0xd7, 0x4b, 0x59, 0x29, 0xe6, 0xe3, 0x49, 0x2c, 0xa9, 0x91, 0x59, 0xcc, 0x84 }, new byte[] { 0x05, 0x3e, 0xb4, 0x79, 0x79, 0xa2, 0x87, 0x34, 0x92, 0x02, 0xa1, 0x8d })]
        [InlineData(new byte[] { 0x65, 0xc1, 0x92, 0xe8, 0xe1, 0xce, 0xce, 0x62, 0x79, 0x0b, 0x98, 0x17, 0x1a, 0x2f, 0xef, 0xff }, new byte[] { 0x2f, 0x1f, 0x8c, 0x51, 0xe5, 0x7e, 0x95, 0x98, 0xf7, 0x7d, 0x08, 0xd8, 0x5f, 0x94, 0xec, 0x92 }, new byte[] { 0xdc, 0xa0, 0x3c, 0xd7, 0x4b, 0x59, 0x29, 0xe6, 0xe3, 0x49, 0x2c, 0xa9, 0x91, 0x59, 0xcc, 0x84 }, new byte[] { 0x05, 0x3e, 0xb4, 0x79, 0x79, 0xa2, 0x87, 0x34 })]
        [InlineData(new byte[] { 0x01, 0x7d, 0x08, 0xd8, 0x5f, 0x94, 0xce, 0xf7, 0x7d, 0x08, 0x2f, 0x1f, 0x8c, 0x2f, 0xef, 0xff }, new byte[] { 0x5f, 0x94, 0xec, 0x92 }, new byte[] {  0x91, 0x59, 0xcc, 0x84 }, new byte[] { 0x99, 0xd2, 0x09, 0xb3, 0x24, 0xb7, 0x31, 0xe2, 0x78, 0x30, 0x63, 0xd6, 0xb5, 0x72, 0x87, 0xbc })]
        [Theory]
        public void ReferenceTests(byte[] key, byte[] iv, byte[] info, byte[] mac)
        {
            GMac gmac = new GMac();
            gmac.Init(key, iv, mac.Length * 8);
            gmac.Process(new ArraySegment<byte>(info));
            byte[] output = gmac.Compute();

            var bcgmac = new Org.BouncyCastle.Crypto.Macs.GMac(new GcmBlockCipher(new AesEngine()), mac.Length * 8);
            bcgmac.Init(new ParametersWithIV(new KeyParameter(key), iv));
            bcgmac.BlockUpdate(info, 0, info.Length);
            byte[] bcmac = new byte[bcgmac.GetMacSize()];
            bcgmac.DoFinal(bcmac, 0);

            Assert.Equal(mac, output);
            Assert.Equal(mac, bcmac);

        }
    }
}
